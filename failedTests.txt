============================= test session starts ==============================
platform linux -- Python 3.11.10, pytest-8.3.4, pluggy-1.5.0 -- /home/runner/workspace/.pythonlibs/bin/python
cachedir: .pytest_cache
rootdir: /home/runner/workspace
configfile: pyproject.toml
plugins: anyio-4.7.0, asyncio-0.25.2, cov-6.0.0
asyncio: mode=Mode.STRICT, asyncio_default_fixture_loop_scope=None
collecting ... collected 8 items / 6 deselected / 2 selected
run-last-failure: rerun previous 2 failures (skipped 9 files)

tests/test_file_upload.py::test_xls_analyzer_date_conversion FAILED      [ 50%]
tests/test_xls_analyzer.py::test_xls_analyzer_dash_to_none_conversion FAILED [100%]

=================================== FAILURES ===================================
______________________ test_xls_analyzer_date_conversion _______________________

self = Index(['Date', 'Week Number', 'Category', 'Month', 'Subcategory', 'Customer',
       'Project', 'Task Description'],
      dtype='object')
key = 'Hours'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
>           return self._engine.get_loc(casted_key)

.pythonlibs/lib/python3.11/site-packages/pandas/core/indexes/base.py:3805: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
index.pyx:167: in pandas._libs.index.IndexEngine.get_loc
    ???
index.pyx:196: in pandas._libs.index.IndexEngine.get_loc
    ???
pandas/_libs/hashtable_class_helper.pxi:7081: in pandas._libs.hashtable.PyObjectHashTable.get_item
    ???
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

>   ???
E   KeyError: 'Hours'

pandas/_libs/hashtable_class_helper.pxi:7089: KeyError

The above exception was the direct cause of the following exception:

file_contents = b'PK\x03\x04\x14\x00\x00\x00\x08\x00\x8b\xa1KZF\xc7MH\x95\x00\x00\x00\xcd\x00\x00\x00\x10\x00\x00\x00docProps/app.xmlM...x00\x80\x01\xe9\x0f\x00\x00[Content_Types].xmlPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00>\x02\x00\x003\x11\x00\x00\x00\x00'

    @staticmethod
    def read_excel(file_contents: bytes) -> List[Dict[str, Any]]:
        """Read Excel file and return list of dictionaries with data."""
        try:
            # Read first sheet from Excel file
            df = pd.read_excel(
                BytesIO(file_contents),
                sheet_name=0,
                dtype={
                    'Week Number': 'Int64',
                    'Month': str,
                    'Category': str,
                    'Subcategory': str,
                    'Customer': str,
                    'Project': str,
                    'Task Description': str
                }
            )
    
            # Set default values for missing columns
            required_columns = ['Week Number', 'Month', 'Category', 'Subcategory',
                              'Customer', 'Project', 'Task Description', 'Date']
            for col in required_columns:
                if col not in df.columns:
                    if col == 'Date':
                        df[col] = pd.Timestamp.now().date()
                    else:
                        df[col] = '-'
    
            # Drop rows where all elements are NaN
            df = df.dropna(how='all')
    
            # Convert date column to datetime
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
    
            # Fill NaN values with appropriate defaults
            # Convert Week Number to numeric, replacing non-numeric with 0
            df['Week Number'] = pd.to_numeric(df['Week Number'], errors='coerce').fillna(0).astype('Int64')
    
            # First replace dashes with nan
            df = df.replace({'-': pd.NA})
    
            # Then fill remaining NaN values with appropriate defaults
            df['Customer'] = df['Customer'].fillna('-')
            df['Project'] = df['Project'].fillna('-')
            df['Task Description'] = df['Task Description'].fillna('')
            df['Month'] = df['Month'].fillna('')
            df['Category'] = df['Category'].fillna('Other')
            df['Subcategory'] = df['Subcategory'].fillna('Other')
>           df['Hours'] = df['Hours'].fillna(0.0)

utils/xls_analyzer.py:60: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
.pythonlibs/lib/python3.11/site-packages/pandas/core/frame.py:4102: in __getitem__
    indexer = self.columns.get_loc(key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = Index(['Date', 'Week Number', 'Category', 'Month', 'Subcategory', 'Customer',
       'Project', 'Task Description'],
      dtype='object')
key = 'Hours'

    def get_loc(self, key):
        """
        Get integer location, slice or boolean mask for requested label.
    
        Parameters
        ----------
        key : label
    
        Returns
        -------
        int if unique index, slice if monotonic index, else mask
    
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
    
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
    
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        casted_key = self._maybe_cast_indexer(key)
        try:
            return self._engine.get_loc(casted_key)
        except KeyError as err:
            if isinstance(casted_key, slice) or (
                isinstance(casted_key, abc.Iterable)
                and any(isinstance(x, slice) for x in casted_key)
            ):
                raise InvalidIndexError(key)
>           raise KeyError(key) from err
E           KeyError: 'Hours'

.pythonlibs/lib/python3.11/site-packages/pandas/core/indexes/base.py:3812: KeyError

During handling of the above exception, another exception occurred:

tmp_path = PosixPath('/tmp/pytest-of-runner/pytest-16/test_xls_analyzer_date_convers0')

    def test_xls_analyzer_date_conversion(tmp_path):
        """Test date conversion in XLSAnalyzer"""
        data = {
            'Date': ['2024-10-07', '2024-10-08'],
            'Week Number': [41, 41],
            'Category': ['Test', 'Test']
        }
        excel_file = create_test_excel(tmp_path, data)
    
        with open(excel_file, "rb") as f:
            contents = f.read()
            analyzer = XLSAnalyzer()
>           records = analyzer.read_excel(contents)

tests/test_file_upload.py:126: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

file_contents = b'PK\x03\x04\x14\x00\x00\x00\x08\x00\x8b\xa1KZF\xc7MH\x95\x00\x00\x00\xcd\x00\x00\x00\x10\x00\x00\x00docProps/app.xmlM...x00\x80\x01\xe9\x0f\x00\x00[Content_Types].xmlPK\x05\x06\x00\x00\x00\x00\t\x00\t\x00>\x02\x00\x003\x11\x00\x00\x00\x00'

    @staticmethod
    def read_excel(file_contents: bytes) -> List[Dict[str, Any]]:
        """Read Excel file and return list of dictionaries with data."""
        try:
            # Read first sheet from Excel file
            df = pd.read_excel(
                BytesIO(file_contents),
                sheet_name=0,
                dtype={
                    'Week Number': 'Int64',
                    'Month': str,
                    'Category': str,
                    'Subcategory': str,
                    'Customer': str,
                    'Project': str,
                    'Task Description': str
                }
            )
    
            # Set default values for missing columns
            required_columns = ['Week Number', 'Month', 'Category', 'Subcategory',
                              'Customer', 'Project', 'Task Description', 'Date']
            for col in required_columns:
                if col not in df.columns:
                    if col == 'Date':
                        df[col] = pd.Timestamp.now().date()
                    else:
                        df[col] = '-'
    
            # Drop rows where all elements are NaN
            df = df.dropna(how='all')
    
            # Convert date column to datetime
            df['Date'] = pd.to_datetime(df['Date'], errors='coerce')
    
            # Fill NaN values with appropriate defaults
            # Convert Week Number to numeric, replacing non-numeric with 0
            df['Week Number'] = pd.to_numeric(df['Week Number'], errors='coerce').fillna(0).astype('Int64')
    
            # First replace dashes with nan
            df = df.replace({'-': pd.NA})
    
            # Then fill remaining NaN values with appropriate defaults
            df['Customer'] = df['Customer'].fillna('-')
            df['Project'] = df['Project'].fillna('-')
            df['Task Description'] = df['Task Description'].fillna('')
            df['Month'] = df['Month'].fillna('')
            df['Category'] = df['Category'].fillna('Other')
            df['Subcategory'] = df['Subcategory'].fillna('Other')
            df['Hours'] = df['Hours'].fillna(0.0)
    
            # Convert DataFrame to list of dictionaries
            records = df.to_dict('records')
    
            logger.info(f"Successfully parsed {len(records)} records from Excel file")
            return records
    
        except Exception as e:
            logger.error(f"Error parsing Excel file: {str(e)}")
>           raise ValueError(f"Failed to parse Excel file: {str(e)}")
E           ValueError: Failed to parse Excel file: 'Hours'

utils/xls_analyzer.py:70: ValueError
----------------------------- Captured stdout call -----------------------------
{"timestamp": "2025-02-11T20:12:22.586768", "level": "ERROR", "correlation_id": "undefined", "logger": "TimesheetTracker", "message": "Error parsing Excel file: 'Hours'", "context": {}}
------------------------------ Captured log call -------------------------------
ERROR    TimesheetTracker:logger.py:32 {"message": "Error parsing Excel file: 'Hours'", "timestamp": "2025-02-11T20:12:22.586914", "context": {}}
__________________ test_xls_analyzer_dash_to_none_conversion ___________________

tmp_path = PosixPath('/tmp/pytest-of-runner/pytest-16/test_xls_analyzer_dash_to_none0')

    def test_xls_analyzer_dash_to_none_conversion(tmp_path):
        """Test that dash values are converted to None during Excel parsing"""
        data = {
            'Category': ['Development'],
            'Customer': ['-'],
            'Project': ['-'],
            'Hours': [8.0],
            'Date': ['2024-10-07']
        }
        excel_file = create_test_excel(tmp_path, data)
    
        with open(excel_file, "rb") as f:
            contents = f.read()
>           analyzer = XLSAnalyzer()
E           NameError: name 'XLSAnalyzer' is not defined

tests/test_xls_analyzer.py:17: NameError
=============================== warnings summary ===============================
.pythonlibs/lib/python3.11/site-packages/pydantic/_internal/_config.py:345
  /home/runner/workspace/.pythonlibs/lib/python3.11/site-packages/pydantic/_internal/_config.py:345: UserWarning: Valid config keys have changed in V2:
  * 'orm_mode' has been renamed to 'from_attributes'
    warnings.warn(message, UserWarning)

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ============================
FAILED tests/test_file_upload.py::test_xls_analyzer_date_conversion - ValueEr...
FAILED tests/test_xls_analyzer.py::test_xls_analyzer_dash_to_none_conversion
================== 2 failed, 6 deselected, 1 warning in 0.47s ==================
